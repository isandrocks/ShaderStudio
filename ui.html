<style>
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }

  body {
    font-family: "Inter", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
      Oxygen, Ubuntu, Cantarell, sans-serif;
    background: #1e1e1e;
    color: #ffffff;
    padding: 16px;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 16px;
  }

  .main-container {
    display: flex;
    gap: 16px;
    align-items: flex-start;
  }

  h2 {
    font-size: 18px;
    font-weight: 600;
    color: #ffffff;
    margin-bottom: 8px;
    text-align: center;
  }

  .preview-container {
    width: 512px;
    height: 512px;
    border-radius: 8px;
    overflow: hidden;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.5), 0 0 0 1px rgba(255, 255, 255, 0.1);
    background: #000000;
  }

  #glCanvas {
    display: block;
    width: 100%;
    height: 100%;
  }

  .button-container {
    display: flex;
    gap: 8px;
    width: 100%;
    max-width: 512px;
  }

  button {
    flex: 1;
    padding: 10px 16px;
    font-size: 13px;
    font-weight: 500;
    font-family: inherit;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    transition: all 0.15s ease;
    outline: none;
  }

  #create {
    background: #0d99ff;
    color: #ffffff;
  }

  #create:hover {
    background: #0c8ce8;
  }

  #create:active {
    background: #0b7cd1;
    transform: scale(0.98);
  }

  #cancel {
    background: #2c2c2c;
    color: #ffffff;
    border: 1px solid #3c3c3c;
  }

  #cancel:hover {
    background: #333333;
  }

  #cancel:active {
    background: #2a2a2a;
    transform: scale(0.98);
  }

  .info-text {
    font-size: 11px;
    color: #999999;
    text-align: center;
    max-width: 512px;
  }

  .controls {
    width: 240px;
    background: #2c2c2c;
    border-radius: 8px;
    padding: 16px;
    display: flex;
    flex-direction: column;
    gap: 16px;
    border: 1px solid #3c3c3c;
  }

  .control-group {
    display: flex;
    flex-direction: column;
    gap: 8px;
  }

  .control-group label {
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 12px;
    font-weight: 500;
    color: #e0e0e0;
  }

  .control-group label span {
    font-family: "Monaco", "Menlo", monospace;
    color: #0d99ff;
    font-weight: 600;
    min-width: 40px;
    text-align: right;
  }

  input[type="range"] {
    width: 100%;
    height: 4px;
    border-radius: 2px;
    background: #1e1e1e;
    outline: none;
    -webkit-appearance: none;
    appearance: none;
    cursor: pointer;
  }

  input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 16px;
    height: 16px;
    border-radius: 50%;
    background: #0d99ff;
    cursor: pointer;
    transition: all 0.15s ease;
  }

  input[type="range"]::-webkit-slider-thumb:hover {
    background: #0c8ce8;
    transform: scale(1.1);
  }

  input[type="range"]::-webkit-slider-thumb:active {
    background: #0b7cd1;
    transform: scale(0.95);
  }

  input[type="range"]::-moz-range-thumb {
    width: 16px;
    height: 16px;
    border-radius: 50%;
    background: #0d99ff;
    cursor: pointer;
    border: none;
    transition: all 0.15s ease;
  }

  input[type="range"]::-moz-range-thumb:hover {
    background: #0c8ce8;
    transform: scale(1.1);
  }

  input[type="range"]::-moz-range-thumb:active {
    background: #0b7cd1;
    transform: scale(0.95);
  }

  input[type="checkbox"] {
    width: 16px;
    height: 16px;
    margin-right: 8px;
    cursor: pointer;
    accent-color: #0d99ff;
  }

  .control-group label:has(input[type="checkbox"]) {
    flex-direction: row;
    justify-content: flex-start;
  }

  .shader-editor-button {
    width: 100%;
    background: #3c3c3c;
    border: 1px solid #4c4c4c;
    padding: 10px;
    font-size: 12px;
    font-weight: 500;
    color: #e0e0e0;
    cursor: pointer;
    border-radius: 6px;
    transition: all 0.15s ease;
  }

  .shader-editor-button:hover {
    background: #454545;
    border-color: #0d99ff;
  }

  .shader-modal {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.8);
    display: none;
    align-items: center;
    justify-content: center;
    z-index: 1000;
    padding: 20px;
  }

  .shader-modal.open {
    display: flex;
  }

  .shader-modal-content {
    background: #2c2c2c;
    border: 1px solid #3c3c3c;
    border-radius: 8px;
    width: 100%;
    max-width: 700px;
    max-height: 90vh;
    display: flex;
    flex-direction: column;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
  }

  .shader-modal-header {
    padding: 16px 20px;
    border-bottom: 1px solid #3c3c3c;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .shader-modal-header h3 {
    font-size: 14px;
    font-weight: 600;
    color: #ffffff;
    margin: 0;
  }

  .close-modal {
    background: none;
    border: none;
    color: #999999;
    font-size: 20px;
    cursor: pointer;
    padding: 0;
    width: 24px;
    height: 24px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 4px;
    transition: all 0.15s ease;
  }

  .close-modal:hover {
    background: #3c3c3c;
    color: #ffffff;
  }

  .shader-modal-body {
    padding: 20px;
    flex: 1;
    overflow-y: auto;
    display: flex;
    flex-direction: column;
    gap: 12px;
  }

  #shaderEditor {
    width: 100%;
    min-height: 400px;
    background: #1e1e1e;
    color: #d4d4d4;
    font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
    font-size: 12px;
    line-height: 1.6;
    padding: 16px;
    border: 1px solid #3c3c3c;
    border-radius: 6px;
    resize: vertical;
    outline: none;
  }

  #shaderEditor:focus {
    border-color: #0d99ff;
  }

  .shader-modal-footer {
    padding: 16px 20px;
    border-top: 1px solid #3c3c3c;
    display: flex;
    gap: 8px;
  }

  .shader-modal-footer button {
    flex: 1;
    padding: 10px 16px;
    font-size: 13px;
  }

  .error-message {
    background: #5c2020;
    border: 1px solid #8b3333;
    color: #ff6b6b;
    padding: 12px;
    border-radius: 6px;
    font-size: 12px;
    display: none;
    max-height: 120px;
    overflow-y: auto;
    font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
    line-height: 1.4;
  }

  .error-message.show {
    display: block;
  }
</style>

<h2>Shader Studio</h2>

<div class="main-container">
  <div class="controls">
    <div class="control-group">
      <label for="speed">Speed: <span id="speed-value">1.0</span></label>
      <input type="range" id="speed" min="0" max="3" step="0.1" value="1.0" />
    </div>

    <div class="control-group">
      <label for="lineCount"
        >Line Count: <span id="lineCount-value">10</span></label
      >
      <input type="range" id="lineCount" min="1" max="20" step="1" value="10" />
    </div>

    <div class="control-group">
      <label for="amplitude"
        >Amplitude: <span id="amplitude-value">0.20</span></label
      >
      <input
        type="range"
        id="amplitude"
        min="0"
        max="0.5"
        step="0.01"
        value="0.2"
      />
    </div>

    <div class="control-group">
      <label for="yOffset"
        >Y Offset: <span id="yOffset-value">0.00</span></label
      >
      <input
        type="range"
        id="yOffset"
        min="-0.5"
        max="0.5"
        step="0.01"
        value="0"
      />
    </div>

    <div class="control-group">
      <label>
        <input type="checkbox" id="pauseTime" />
        Pause Animation
      </label>
    </div>

    <button class="shader-editor-button" id="openShaderEditor">
      Advanced Editor
    </button>

    <div class="button-container">
      <button id="create">Create</button>
      <button id="cancel">Cancel</button>
    </div>
  </div>

  <div class="preview-container">
    <canvas id="glCanvas" width="512" height="512"></canvas>
  </div>
</div>

<p class="info-text">
  Live shader preview above • Adjust parameters in real-time
</p>

<!-- Shader Editor Modal -->
<div class="shader-modal" id="shaderModal">
  <div class="shader-modal-content">
    <div class="shader-modal-header">
      <h3>Advanced Shader Editor</h3>
      <button class="close-modal" id="closeModal">✕</button>
    </div>
    <div class="shader-modal-body">
      <textarea id="shaderEditor" spellcheck="false" aria-label="GLSL Fragment Shader Code"></textarea>
      <div class="error-message" id="shaderError"></div>
    </div>
    <div class="shader-modal-footer">
      <button id="resetShader">Reset to Default</button>
      <button id="reloadShader">Apply Shader</button>
    </div>
  </div>
</div>

<script>
  // Shader sources
  const VERTEX_SHADER = `
  attribute vec2 a_position;
  void main() {
    gl_Position = vec4(a_position, 0, 1);
  }
`;

  const FRAGMENT_SHADER = `
  precision mediump float;
  uniform vec2 iResolution;
  uniform float iTime;
  uniform float uSpeed;
  uniform float uLineCount;
  uniform float uAmplitude;
  uniform float uYOffset;
  
  const float MAX_LINES = 20.0;
  
  float wave(vec2 uv, float speed, float yPos, float thickness, float softness) {
    float falloff = smoothstep(1., 0.5, abs(uv.x));
    float y = falloff * sin(iTime * speed + uv.x * 10.0) * yPos - uYOffset;
    return 1.0 - smoothstep(thickness, thickness + softness + falloff * 0.0, abs(uv.y - y));
  }
  
  void main() {
    vec2 uv = gl_FragCoord.xy / iResolution.y;
    vec4 col = vec4(0.0, 0.0, 0.0, 1.0);
    
    vec3 gradCol1 = vec3(0.2, 0.1, 0.0);
    vec3 gradCol2 = vec3(0.2, 0.0, 0.2);
    col.xyz = mix(gradCol1, gradCol2, uv.x + uv.y);
    
    uv -= 0.5;
    
    const vec3 col1 = vec3(0.2, 0.5, 0.9);
    const vec3 col2 = vec3(0.9, 0.3, 0.9);
    float aaDy = iResolution.y * 0.000005;
    
    for (float i = 0.; i < MAX_LINES; i += 1.) {
      if (i <= uLineCount) {
        float t = i / (uLineCount - 1.0);
        vec3 lineCol = mix(col1, col2, t);
        float bokeh = pow(t, 3.0);
        float thickness = 0.003;
        float softness = aaDy + bokeh * 0.2;
        float amp = uAmplitude - 0.05 * t;
        float amt = max(0.0, pow(1.0 - bokeh, 2.0) * 0.9);
        col.xyz += wave(uv, uSpeed * (1.0 + t), uAmplitude, thickness, softness) * lineCol * amt;
      }
    }
    
    gl_FragColor = col;
  }
`;

  // Global state
  const state = {
    gl: null,
    program: null,
    canvas: null,
    uniforms: {},
    startTime: Date.now(),
    params: {
      speed: 1.0,
      lineCount: 10.0,
      amplitude: 0.2,
      yOffset: 0.0,
      paused: false,
      pausedTime: 0.0,
    },
    customFragmentShader: null,
  };

  const DEFAULT_FRAGMENT_SHADER = FRAGMENT_SHADER;

  // Helper functions
  function sendError(message) {
    parent.postMessage(
      { pluginMessage: { type: "shader-error", error: message } },
      "*"
    );
  }

  function getCurrentTime() {
    return state.params.paused
      ? state.params.pausedTime
      : (Date.now() - state.startTime) / 1000.0;
  }

  function createShader(type, source) {
    const shader = state.gl.createShader(type);
    state.gl.shaderSource(shader, source);
    state.gl.compileShader(shader);

    if (!state.gl.getShaderParameter(shader, state.gl.COMPILE_STATUS)) {
      console.error("Shader error:", state.gl.getShaderInfoLog(shader));
      state.gl.deleteShader(shader);
      return null;
    }
    return shader;
  }

  function initWebGL() {
    state.canvas = document.getElementById("glCanvas");
    state.gl = state.canvas.getContext("webgl");

    if (!state.gl) {
      sendError("WebGL not supported");
      return false;
    }

    const vertexShader = createShader(state.gl.VERTEX_SHADER, VERTEX_SHADER);
    const fragmentShaderSource = state.customFragmentShader || FRAGMENT_SHADER;
    const fragmentShader = createShader(
      state.gl.FRAGMENT_SHADER,
      fragmentShaderSource
    );

    if (!vertexShader || !fragmentShader) {
      sendError("Failed to create shaders");
      return false;
    }

    state.program = state.gl.createProgram();
    state.gl.attachShader(state.program, vertexShader);
    state.gl.attachShader(state.program, fragmentShader);
    state.gl.linkProgram(state.program);

    if (!state.gl.getProgramParameter(state.program, state.gl.LINK_STATUS)) {
      console.error(
        "Program error:",
        state.gl.getProgramInfoLog(state.program)
      );
      sendError("Failed to create shader program");
      return false;
    }

    // Setup geometry
    const positionBuffer = state.gl.createBuffer();
    state.gl.bindBuffer(state.gl.ARRAY_BUFFER, positionBuffer);
    state.gl.bufferData(
      state.gl.ARRAY_BUFFER,
      new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]),
      state.gl.STATIC_DRAW
    );

    // Get uniform locations
    state.uniforms = {
      position: state.gl.getAttribLocation(state.program, "a_position"),
      resolution: state.gl.getUniformLocation(state.program, "iResolution"),
      time: state.gl.getUniformLocation(state.program, "iTime"),
      speed: state.gl.getUniformLocation(state.program, "uSpeed"),
      lineCount: state.gl.getUniformLocation(state.program, "uLineCount"),
      amplitude: state.gl.getUniformLocation(state.program, "uAmplitude"),
      yOffset: state.gl.getUniformLocation(state.program, "uYOffset"),
    };

    return true;
  }

  function renderShader() {
    if (!state.gl || !state.program) return;

    state.gl.useProgram(state.program);
    state.gl.enableVertexAttribArray(state.uniforms.position);
    state.gl.vertexAttribPointer(
      state.uniforms.position,
      2,
      state.gl.FLOAT,
      false,
      0,
      0
    );

    // Set uniforms
    state.gl.uniform2f(
      state.uniforms.resolution,
      state.canvas.width,
      state.canvas.height
    );
    state.gl.uniform1f(state.uniforms.time, getCurrentTime());
    state.gl.uniform1f(state.uniforms.speed, state.params.speed);
    state.gl.uniform1f(state.uniforms.lineCount, state.params.lineCount);
    state.gl.uniform1f(state.uniforms.amplitude, state.params.amplitude);
    state.gl.uniform1f(state.uniforms.yOffset, state.params.yOffset);

    state.gl.clearColor(0, 0, 0, 1);
    state.gl.clear(state.gl.COLOR_BUFFER_BIT);
    state.gl.drawArrays(state.gl.TRIANGLE_STRIP, 0, 4);
  }

  function renderLoop() {
    renderShader();
    requestAnimationFrame(renderLoop);
  }

  function captureShader() {
    if (!state.gl) {
      sendError("WebGL context not available");
      return;
    }

    try {
      renderShader();

      state.canvas.toBlob((blob) => {
        if (!blob) {
          sendError("Failed to create image blob");
          return;
        }

        blob
          .arrayBuffer()
          .then((buffer) => {
            parent.postMessage(
              {
                pluginMessage: {
                  type: "shader-rendered",
                  imageData: new Uint8Array(buffer),
                },
              },
              "*"
            );
          })
          .catch((error) => {
            sendError("Error converting image: " + error.message);
          });
      }, "image/png");
    } catch (error) {
      sendError("Error capturing pixels: " + error.message);
    }
  }

  function recompileShader() {
    const shaderSource = document.getElementById("shaderEditor").value;
    const errorDiv = document.getElementById("shaderError");
    
    // Clear previous error
    errorDiv.classList.remove("show");
    errorDiv.textContent = "";

    try {
      // Try to compile the new shader
      const testFragmentShader = createShader(state.gl.FRAGMENT_SHADER, shaderSource);
      
      if (!testFragmentShader) {
        const log = state.gl.getShaderInfoLog(state.gl.createShader(state.gl.FRAGMENT_SHADER));
        throw new Error(log || "Shader compilation failed");
      }

      // Create new program
      const vertexShader = createShader(state.gl.VERTEX_SHADER, VERTEX_SHADER);
      const newProgram = state.gl.createProgram();
      state.gl.attachShader(newProgram, vertexShader);
      state.gl.attachShader(newProgram, testFragmentShader);
      state.gl.linkProgram(newProgram);

      if (!state.gl.getProgramParameter(newProgram, state.gl.LINK_STATUS)) {
        const log = state.gl.getProgramInfoLog(newProgram);
        throw new Error(log || "Program linking failed");
      }

      // Success! Update the program
      if (state.program) {
        state.gl.deleteProgram(state.program);
      }
      
      state.program = newProgram;
      state.customFragmentShader = shaderSource;

      // Re-get uniform locations
      state.uniforms = {
        position: state.gl.getAttribLocation(state.program, "a_position"),
        resolution: state.gl.getUniformLocation(state.program, "iResolution"),
        time: state.gl.getUniformLocation(state.program, "iTime"),
        speed: state.gl.getUniformLocation(state.program, "uSpeed"),
        lineCount: state.gl.getUniformLocation(state.program, "uLineCount"),
        amplitude: state.gl.getUniformLocation(state.program, "uAmplitude"),
        yOffset: state.gl.getUniformLocation(state.program, "uYOffset"),
      };

      // Setup geometry buffer again
      const positionBuffer = state.gl.createBuffer();
      state.gl.bindBuffer(state.gl.ARRAY_BUFFER, positionBuffer);
      state.gl.bufferData(
        state.gl.ARRAY_BUFFER,
        new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]),
        state.gl.STATIC_DRAW
      );

      return true;
    } catch (error) {
      errorDiv.textContent = "Shader Error: " + error.message;
      errorDiv.classList.add("show");
      return false;
    }
  }

  // UI Event handlers
  function setupControls() {
    // Initialize shader editor with current shader
    document.getElementById("shaderEditor").value = DEFAULT_FRAGMENT_SHADER;

    // Modal controls
    const modal = document.getElementById("shaderModal");
    
    document.getElementById("openShaderEditor").addEventListener("click", () => {
      modal.classList.add("open");
      // Update textarea with current shader (in case it was modified)
      const currentShader = state.customFragmentShader || DEFAULT_FRAGMENT_SHADER;
      document.getElementById("shaderEditor").value = currentShader;
    });

    document.getElementById("closeModal").addEventListener("click", () => {
      modal.classList.remove("open");
    });

    // Close modal when clicking outside
    modal.addEventListener("click", (e) => {
      if (e.target === modal) {
        modal.classList.remove("open");
      }
    });

    // Shader editor buttons
    document.getElementById("reloadShader").addEventListener("click", () => {
      if (recompileShader()) {
        // Clear error on success
        document.getElementById("shaderError").classList.remove("show");
      }
    });

    document.getElementById("resetShader").addEventListener("click", () => {
      document.getElementById("shaderEditor").value = DEFAULT_FRAGMENT_SHADER;
      state.customFragmentShader = null;
      recompileShader();
    });

    const controls = [
      { id: "speed", key: "speed", format: (v) => v.toFixed(1) },
      { id: "lineCount", key: "lineCount", format: Math.round },
      { id: "amplitude", key: "amplitude", format: (v) => v.toFixed(2) },
      { id: "yOffset", key: "yOffset", format: (v) => v.toFixed(2) },
    ];

    controls.forEach(({ id, key, format }) => {
      document.getElementById(id).addEventListener("input", (e) => {
        state.params[key] = parseFloat(e.target.value);
        document.getElementById(`${id}-value`).textContent = format(
          state.params[key]
        );
      });
    });

    document.getElementById("pauseTime").addEventListener("change", (e) => {
      if (e.target.checked) {
        // Pausing: capture current time
        state.params.pausedTime = (Date.now() - state.startTime) / 1000.0;
        state.params.paused = true;
      } else {
        // Unpausing: adjust startTime to continue from where we paused
        state.startTime = Date.now() - state.params.pausedTime * 1000;
        state.params.paused = false;
      }
    });

    document.getElementById("create").onclick = () => {
      parent.postMessage({ pluginMessage: { type: "create-rectangle" } }, "*");
    };

    document.getElementById("cancel").onclick = () => {
      parent.postMessage({ pluginMessage: { type: "cancel" } }, "*");
    };
  }

  // Message handler
  onmessage = (event) => {
    if (event.data.pluginMessage.type === "render-shader") {
      captureShader();
    }
  };

  // Initialize
  if (initWebGL()) {
    setupControls();
    renderLoop();
  } else {
    console.error("Failed to initialize WebGL");
  }
</script>
